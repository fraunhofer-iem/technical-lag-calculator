//package vulnerabilities
//
//import artifact.model.VersionDto
//import http.deps.DepsClient
//import kotlinx.coroutines.Dispatchers
//import kotlinx.coroutines.withContext
//import kotlinx.serialization.json.Json
//import vulnerabilities.dto.osv.OpenSourceVulnerabilityFormat
//import java.nio.file.Path
//import kotlin.io.path.createDirectory
//
//class VulnerabilityVersionDownloader(private val depsClient: DepsClient = DepsClient()) {
//
//    suspend fun storeVersionsForVulnerablePackages(filePath: Path) {
//        val vulnerabilities = VulnerabilityHelper.readVulnerabilitiesFromFile(filePath)
//        val packageWithVersions = addVersionInformationForVulnerablePackages(vulnerabilities)
//        val outputPath = filePath.resolve("output").createDirectory()
//        packageWithVersions.forEachIndexed { index, osv ->
//            val outputFile = outputPath.resolve("${osv.id}.json").toFile()
//            withContext(Dispatchers.IO) {
//                try {
//                    outputFile.createNewFile()
//                    val json = Json { prettyPrint = true }
//                    val jsonString =
//                        json.encodeToString(OpenSourceVulnerabilityFormat.serializer(), osv)
//                    outputFile.writeText(jsonString)
//                } catch (exception: Exception) {
//                    println("Writing result file for ${osv.id} failed with $exception")
//                }
//            }
//        }
//    }
//
//    private suspend fun addVersionInformationForVulnerablePackages(vulnerabilities: List<OpenSourceVulnerabilityFormat>)
//            : List<OpenSourceVulnerabilityFormat> {
//        val seenPackages = HashMap<String, List<VersionDto>>()
//        vulnerabilities.forEach { vulnerability ->
//            vulnerability.affected.forEach { affected ->
//                if (affected.packageX?.name != null &&
//                    affected.packageX.ecosystem != null
//                ) {
//                    println("Processing package ${affected.packageX}")
//                    val versions = if (!seenPackages.contains(affected.packageX.name)) {
//                        val queriedVersions = if (affected.packageX.name.contains("/")) {
//                            val splitName = affected.packageX.name.split("/")
//                            val nameSpace = splitName[0]
//                            val name = splitName[1]
//                            depsClient.getVersionsForPackage(
//                                ecosystem = affected.packageX.ecosystem,
//                                name = name,
//                                namespace = nameSpace
//                            )
//
//                        } else {
//                            depsClient.getVersionsForPackage(
//                                ecosystem = affected.packageX.ecosystem,
//                                name = affected.packageX.name,
//                            )
//                        }
//
//                        seenPackages[affected.packageX.name] = queriedVersions
//                        queriedVersions
//
//                    } else {
//                        seenPackages[affected.packageX.name]
//                    }
//                    affected.packageX.versions?.addAll(versions ?: emptyList())
//                }
//            }
//        }
//        return vulnerabilities
//    }
//
//}