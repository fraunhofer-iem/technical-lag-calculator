//package vulnerabilities
//
//import kotlinx.datetime.Instant
//import kotlinx.datetime.TimeZone
//import kotlinx.datetime.toLocalDateTime
//import org.jetbrains.exposed.sql.SizedCollection
//import util.dbQuery
//import vulnerabilities.dto.osv.OpenSourceVulnerabilityFormat
//import vulnerabilities.entity.Version
//import vulnerabilities.entity.Vulnerability
//import java.nio.file.Path
//import kotlin.time.Duration
//
//data class VulnerabilityStatistics(
//    // how many vulnerabilities are in our dataset
//    val numberOfVulnerabilities: Int,
//    // what is the time difference between the report date
//    // of a vulnerability and the release date of the oldest
//    // version to which the vulnerability applies (one entry
//    // per vulnerability)
//    val timeDifferences: MutableList<Int>,
//    // see timeDifferences, just counting how many versions
//    // are mapped to one vulnerability
//    val versionDifferences: MutableList<Int>
//)
//
//class VulnerabilityAnalyzer(private val filePath: Path) {
//
//
//    private val allVulnerabilities: MutableList<OpenSourceVulnerabilityFormat> =
//        VulnerabilityHelper.readVulnerabilitiesFromFile(filePath).toMutableList()
//
//
//    init {
//        removeIncompleteData()
//    }
//
//    suspend fun dbExport() {
//        dbQuery {
//            val packageToVersions: MutableMap<String, SizedCollection<Version>> = mutableMapOf()
//            allVulnerabilities.forEach { vul ->
//                val vulPublishedDate = Instant.parse(vul.published)
//                val id = vul.id
//                vul.affected.forEach { affected ->
//                    affected.ranges.forEach { range ->
//                        val introduced = range.events.find { it.introduced != null }
//                        val fixed = range.events.find { it.fixed != null }
//                        if (introduced != null) {
//                            val pkgName = affected.packageX.name
//                            val vulnerability = Vulnerability.new {
//                                vulnerabilityId = id
//                                publishedDate = vulPublishedDate.toLocalDateTime(timeZone = TimeZone.UTC).date
//                                packageName = pkgName
//                                introducedVersion = introduced.introduced!!
//                                fixedVersion = fixed?.fixed
//                            }
//                            val versionEntities = if (packageToVersions.contains(pkgName)) {
//                                packageToVersions[pkgName]!!
//                            } else {
//                                val vers = SizedCollection(affected.packageX.versions.map { pkgVersion ->
//                                    Version.new {
//                                        versionNumber = pkgVersion.versionNumber
//                                        publishedDate = Instant.parse(pkgVersion.released)
//                                            .toLocalDateTime(timeZone = TimeZone.UTC).date
//                                    }
//                                })
//                                packageToVersions[pkgName] = vers
//                                vers
//                            }
//
//                            vulnerability.versions = versionEntities
//                        }
//                    }
//
//                }
//
//            }
////            val vul = allVulnerabilities.first()
//
////            allVulnerabilities.forEach {
////                Vulnerability.new {
////                    vulnerability = it
////                }
////            }
//        }
//    }
//
//    fun histogram(): Map<Long, Int> {
//        var versionsWithoutMatch = 0
//        val durations = allVulnerabilities.flatMap { vulnerability ->
//            val publishedDate = Instant.parse(vulnerability.published)
//            vulnerability.affected.flatMap { affected ->
//                val versions = affected.packageX.versions
//                affected.ranges.flatMap { range ->
//                    range.events.mapNotNull { event ->
//                        val introducedVersion = event.introduced
//                        val version = versions.find { it.versionNumber == introducedVersion }
//                        if (version == null) {
//                            versionsWithoutMatch += 1
//                        }
//                        version?.released?.let {
//                            val versionReleaseDate = Instant.parse(it)
//                            return@mapNotNull publishedDate.minus(versionReleaseDate).inWholeDays
//                        }
//                        return@mapNotNull null
//                    }
//                }
//            }
//        }
//        val sortedNumbers = durations.sorted()
//
//        val size = sortedNumbers.size
//        val index50 = (size * 0.5).toInt()
//        val index70 = (size * 0.7).toInt()
//        val index90 = (size * 0.9).toInt()
//
//        val percentile50 = sortedNumbers[index50]
//        val percentile70 = sortedNumbers[index70]
//        val percentile90 = sortedNumbers[index90]
//
//        println("50% percentile $percentile50, 70% percentile $percentile70, 90% percentile $percentile90")
//
//        println("Versions without match $versionsWithoutMatch")
//        val noOutlier = durations.toMutableList()
//        println("previous count ${noOutlier.count()}")
//        noOutlier.removeAll { it > 900L }
//        println("after remove count ${noOutlier.count()}")
//        val occurrencesMap = mutableMapOf<Long, Int>()
//
//
//        for (value in noOutlier) {
//            val intervalStart = (value / 7)
//            occurrencesMap[intervalStart] = occurrencesMap.getOrDefault(intervalStart, 0) + 1
//        }
//
//
//        return occurrencesMap
//    }
//
//    fun analyze() {
//
//
//        //TODO: only use vulnerabilities with a specific "introduced" value (precise, but small dataset)
//        var noIntroduced = allVulnerabilities.count()
//        allVulnerabilities.forEach {
//            it.affected.forEach {
//                it.ranges.forEach {
//                    it.events.removeAll { it.introduced == "0" }
//                }
//                it.ranges.removeAll { it.events.isEmpty() }
//            }
//        }
//        allVulnerabilities.removeAll { it.affected.none { it.ranges.isNotEmpty() } }
//        noIntroduced -= allVulnerabilities.count()
//
//        println(
//            "Vulnerabilities with no concrete introduced value $noIntroduced.\n" +
//                    "Remaining ${allVulnerabilities.count()}"
//        )
//        val diffs: MutableList<Duration> = mutableListOf()
////        allVulnerabilities.forEach { vulnerability ->
////            // Using kotlinx.datetime.Instant
////            val publishedInstant = Instant.parse(vulnerability.published)
////
////            // each distinct package is counted separately for the same vulnerability
//////            val distinctAffected = vulnerability.affected.distinctBy { it.packageX.name }
////            vulnerability.affected.forEach { affected ->
////                try {
////                    // TODO: this is strange
////                    val smallest =
////                        vulnerability.affected.minOf { it.ranges.minOf { it.events.minOf { it.introduced } } }
////                    affected.packageX.versions.find { it.versionNumber == smallest }.let { smallestVersion ->
////                        smallestVersion?.let {
////                            val versionReleaseDate = Instant.parse(it.released)
////                            diffs.add(publishedInstant.minus(versionReleaseDate))
////                        }
////                    }
////                } catch (exception: Exception) {
////                    println("calculation failed with $exception")
////                }
////            }
////        }
//        val avgDays = diffs.sumOf { it.inWholeDays } / diffs.count()
//        println("Avg days after version release until published vulnerability $avgDays")
//
//        //TODO: use all vulnerabilities for which we have version information and make the time diff between
//        // the vulnerability found date and the latest release before the vulnerability was found (optimistic)
//
//        //TODO: make the diff between the report time and the oldest minor or patch version (maybe realistic?)
////        val haveIntroducedValue = allVulnerabilities.filter { vul ->
////            vul.affected.any { affected ->
////                affected.ranges?.any { range ->
////                    range?.events?.any { event ->
////                        event?.introduced != null && event.introduced != "0"
////                    } ?: false
////                } ?: false
////            }
////        }
//    }
//
//    private fun removeIncompleteData() {
//
//        println(
//            "Started with ${allVulnerabilities.size} vulnerabilities. \n " +
//                    "Removing incomplete data."
//        )
//        var noIntroducedValue = allVulnerabilities.count()
//
//        allVulnerabilities.forEach {
//            it.affected.forEach {
//                it.ranges.forEach {
//                    it.events.removeAll { it.introduced == "-1" }
//                }
//                it.ranges.removeAll { it.events.isEmpty() }
//            }
//        }
//
//        allVulnerabilities.removeAll { it.affected.none { it.ranges.isNotEmpty() } }
//
//        noIntroducedValue -= allVulnerabilities.count()
//        var noVersions = allVulnerabilities.count()
//        allVulnerabilities.removeAll { it.affected.none { it.packageX.versions?.isNotEmpty() ?: true } }
//        noVersions -= allVulnerabilities.count()
//
//        val incompleteInformationCount = noVersions + noIntroducedValue
//
//        println(
//            "Vulnerabilities with no introduced value ($noIntroducedValue) or no version information ($noVersions)\n" +
//                    "Removed vulnerabilities: $incompleteInformationCount, remaining ${allVulnerabilities.size}. "
//        )
//    }
//
//}